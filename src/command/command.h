/* Copyright (c) 2017-2018 the Volcano Authors. Licensed under the GPLv3.
 *
 * src/command is the 3rd-level bindings for the Vulkan graphics library.
 * src/command is part of github.com/ndsol/volcano.
 * This library is called "command" as a homage to Star Trek First Contact.
 * Like the Vulcan High Command, this library sends out the commands.
 *
 * This library has 3 sub-categories, all interdependent:
 *
 * 1. The RenderPass uses these classes:
 *    * RenderPass
 *    * Pipeline
 *    * PipelineCreateInfo
 *    * PipelineStage
 *    * Shader
 *
 * 2. The Semaphore, Fence, and Event classes
 *    (in fence.h to break things up a little - DO NOT #include THAT FILE,
 *     just #include <src/command/command.h> to get all of this.)
 *
 * 3. The CommandPool, SubmitInfo and CommandBuffer classes
 *    (in command_buffer.h to break things up a little - DO NOT #include THAT
 *     FILE, just #include <src/command/command.h> to get all of this.)
 */

#include <src/language/language.h>

#include <memory>
#include <set>
#include <string>
// "command_builder.h" is #included at the end of the file (see below).

#pragma once

using language::VkDebugPtr;

namespace command {

// Shader represents the compiled SPIR-V code generated by glslangVerifier.
// To add your Shader objects to a Pipeline:
// 1. Allocate the Shader:
//    auto shader = std::make_shared<command::Shader>(dev);
// 2. Load the SPIR-V code from a file (or somewhere else):
//    if (shader->loadSPV("filename.spv")) { ... }
// 3. Call PipelineCreateInfo::addShader(shader, ...), which will also add the
//    shader to the RenderPass.
//
// Or a simpler approach is to use science::ShaderLibrary.
typedef struct Shader {
  Shader(language::Device& dev) : vk{dev, vkDestroyShaderModule} {
    vk.allocator = dev.dev.allocator;
  }
  Shader(Shader&&) = default;
  Shader(const Shader& other) = delete;

  // loadSPV loads the SPIR-V bytecode in spvBegin into the Shader.
  WARN_UNUSED_RESULT int loadSPV(const uint32_t* spvBegin, size_t len);
  // loadSPV is a convenience method for a buffer of a different type.
  WARN_UNUSED_RESULT int loadSPV(const void* spvBegin, size_t len) {
    return loadSPV(reinterpret_cast<const uint32_t*>(spvBegin), len);
  }
  // loadSPV is a convenience method for a sub-buffer within a larger buffer.
  WARN_UNUSED_RESULT int loadSPV(const void* spvBegin, const void* spvEnd) {
    return loadSPV(spvBegin, reinterpret_cast<const char*>(spvEnd) -
                                 reinterpret_cast<const char*>(spvBegin));
  }
  // loadSPV is a convenience method for loading from a std::vector.
  WARN_UNUSED_RESULT int loadSPV(const std::vector<char>& spv) {
    return loadSPV(&*spv.begin(), &*spv.end());
  }
  // loadSPV is a convenience method for loading from a std::vector.
  WARN_UNUSED_RESULT int loadSPV(const std::vector<uint32_t>& spv) {
    return loadSPV(&*spv.begin(), &*spv.end());
  }
  // loadSPV is a convenience method for loading from a file.
  WARN_UNUSED_RESULT int loadSPV(const char* filename);
  // loadSPV is a convenience method for loading from a file.
  WARN_UNUSED_RESULT int loadSPV(std::string filename) {
    return loadSPV(filename.c_str());
  }

  // setName forwards the setName call to vk.
  WARN_UNUSED_RESULT int setName(const std::string& name) {
    return vk.setName(name);
  }
  // getName forwards the getName call to vk.
  const std::string& getName() const { return vk.getName(); }

  // vk is the underlying raw Vulkan Shader Module object.
  VkDebugPtr<VkShaderModule> vk;
  // bytes are the raw uint32_t's of the compiled shader. Vulkan itself does
  // not need your app to store these bytes on the CPU, but spirv_cross
  // reflection is done on the CPU and needs them.
  std::vector<uint32_t> bytes;
} Shader;

// PipelineAttachment constructs a VkAttachmentDescription2KHR. When it is
// added to the VkRenderPassCreateInfo2KHR in RenderPass::ctorError(), it is
// given an index -- written to VkAttachmentReference2KHR refvk here. The refvk
// is then added to the PipelineCreateInfo::subpassDesc.
typedef struct PipelineAttachment {
  // Construct a PipelineAttachment which corresponds to a
  // Framebuffer attachment with the given VkFormat and VkImageLayout.
  PipelineAttachment(VkFormat format, VkImageLayout refLayout);

  // aspectMaskFromFormat() finds all possible VkImageAspectFlags for a format.
  // VK_IMAGE_ASPECT_METADATA_BIT is not handled. See Image::getAllAspects().
  static VkImageAspectFlags aspectMaskFromFormat(VkFormat format);

  VkAttachmentReference2KHR refvk;
  VkAttachmentDescription2KHR vk;
} PipelineAttachment;

// PipelineStage is the entrypoint to run a Shader as one of the programmable
// pipeline stages. (See the description of Pipeline, below.)
//
// PipelineStage::entryPoint sets what function is "main()" in the Shader.
// A library of useful code can be built as a single large shader with several
// entryPointNames -- glslangVerifier can build many source files as one unit.
//
// Or, keep it simple: set entryPointName = "main" on all your shaders to make
// them feel like "C".
//
// TODO: Find out if Vulkan errors out if two PipelineStages are added for the
// same stage. For example, two VK_SHADER_STAGE_VERTEX_BIT.
typedef struct PipelineStage {
  PipelineStage() {
    memset(&info, 0, sizeof(info));
    info.sType = autoSType(info);
  }

  std::shared_ptr<Shader> shader;
  std::string entryPointName;

  // specialization is a byte array held until the pipeline is created. This is
  // because it contains a user-defined struct. The VkSpecializationInfo which
  // it represents is created in Pipeline::init().
  //
  // The glslangValidator rule that runs copy_header auto-generates the map and
  // info for you; just call Pipeline::specialize() to populate this.
  std::vector<uint8_t> specialization;

  // specializationMap is used in Pipeline::init() if specialization is set.
  std::vector<VkSpecializationMapEntry> specializationMap;

  // specialize() is called by Pipeline::specialize() to copy the user bytes.
  void specialize(std::vector<VkSpecializationMapEntry> map,
                  const VkSpecializationInfo& si) {
    specializationMap.swap(map);
    specialization.resize(si.dataSize);
    memcpy(specialization.data(), si.pData, specialization.size());
  }

  // You must initialize info.flag, but do not initialize
  // info.module and info.pName. They will be written by Pipeline::init().
  VkPipelineShaderStageCreateInfo info;
} PipelineStage;

// Forward declaration of RenderPass for Pipeline and PipelineCreateInfo.
struct RenderPass;

// Vulkan defines a render pipeline in terms of the following stages:
// 1. Input assembly: fixed function, reads input data.
// 2. Vertex shader: programmable, operates on input vertices, uniforms, etc.
// 3. Tesselation shader: programmable, reads the vertex shader's output and
//    produces a different number of vertices.
// 4. Geometry shader: programmable. Most GPUs cannot do geometry shading with
//    reasonable performance (the notable exception is Intel).
// 5. Rasterizer: fixed function, draws triangles / lines / points.
// 6. Fragment shader: programmable, operates on each "fragment" (each pixel).
// 7. Color blend: fixed function, writes fragments to the frame buffer.
//
// Use Pipeline in the following order:
// 1. Instantiate a Pipeline by calling RenderPass::addPipeline() or
//    declare a science::PipeBuilder and construct it by passing in RenderPass.
// 2. Customize the Pipeline::info, including calling addShader().
// 3. Call RenderPass:ctorError() to create the vulkan objects.
//
// PipelineCreateInfo is the Pipeline::info. A VkPipelineLayoutCreateInfo is
// built from this class in Pipeline::init, called from RenderPass::ctorError.
//
// Compute pipelines are created by constructing a Pipeline using the
// constructor for a compute shader. Again, customize the Pipeline::info to
// meet app needs before use.
typedef struct PipelineCreateInfo {
  // PipelineCreateInfo uses pass.getTargetExtent() and pass.getTargetFormat()
  // to set defaults for convenience. A Pipeline can be used for more than one
  // RenderPass, and you can change the defaults to suit your app.
  //
  // This constructor is for a graphics pipeline.
  PipelineCreateInfo(RenderPass& pass);

  // PipelineCreateInfo for a compute pipeline.
  // computeShader is the compiled shader that will be run.
  // entryPointName is the name of the function to use (defaults to "main").
  PipelineCreateInfo(std::shared_ptr<command::Shader> computeShader,
                     std::string entryPointName = "main");

  // stages contains the PipelineStage for each stage in the pipeline that
  // runs a shader. To add a stage, call addShader() below.
  //
  // For compute pipelines, the constructor creates the single stage.
  //
  // Fixed-function stages are configured by changing members below such as
  // rastersci, perFramebufColorBlend, etc.
  std::vector<PipelineStage> stages;

  // addShader adds a PipelineStage to stages, holding a reference to it in
  // renderPass to de-duplicate shaders. Shaders can be added more than once.
  //
  // Your app may add a shader to the pipeline this way, specifying the
  // stageBits and entryPointName yourself, but if you prefer, look at
  // science::ShaderLibrary if you would like to automatically (via spirv_cross
  // reflection) add the pipeline.
  //
  // NOTE: This is for graphics pipelines only. Compute pipelines do not have
  // a RenderPass.
  WARN_UNUSED_RESULT int addShader(RenderPass& pass,
                                   std::shared_ptr<Shader> shader,
                                   VkShaderStageFlagBits stageBits,
                                   std::string entryPointName = "main");

  // Helper function to create a blend state of "just write these pixels."
  static VkPipelineColorBlendAttachmentState withDisabledAlpha();

  // Helper function to create a blend state "do normal RGBA alpha blending."
  static VkPipelineColorBlendAttachmentState withEnabledAlpha();

  // Optionally modify these structures before calling RenderPass::ctorError().
  VkPipelineVertexInputStateCreateInfo vertsci;
  VkPipelineInputAssemblyStateCreateInfo asci;

  // Optionally modify these structures before calling RenderPass::ctorError().
  // viewports and scissors will be written to viewsci by Pipeline::init().
  // Optionally update the viewports and scissors in-place and use them in
  // CommandBuilder::setViewport() and CommandBuilder::setScissor()
  std::vector<VkViewport> viewports;
  std::vector<VkRect2D> scissors;
  VkPipelineViewportStateCreateInfo viewsci;

  // Optionally modify these structures before calling RenderPass::ctorError().
  VkPipelineRasterizationStateCreateInfo rastersci;
  VkPipelineMultisampleStateCreateInfo multisci;
  VkPipelineDepthStencilStateCreateInfo depthsci;

  // Use vkCreateDescriptorSetLayout to create layouts, which then
  // auto-generates VkPipelineLayoutCreateInfo.
  std::vector<VkDescriptorSetLayout> setLayouts;
  std::vector<VkPushConstantRange> pushConstants;

  std::vector<VkDynamicState> dynamicStates;

  // Optionally modify these structures before calling RenderPass::ctorError().
  // perFramebufColorBlend will be written to cbsci by Pipeline::init().
  std::vector<VkPipelineColorBlendAttachmentState> perFramebufColorBlend;
  VkPipelineColorBlendStateCreateInfo cbsci;

  // Optionally modify these structures before calling RenderPass::ctorError().
  // The PipelineAttachment::VkAttachmentReference2KHR::attachment index is set
  // by RenderPass::ctorError(), then written to
  // PipelineCreateInfo::subpassDesc.
  //
  // Any attach here must also be added to Framebuf::attachments. The spec says
  // under VkFramebufferCreateInfo: "attachmentCount must be equal to the
  // attachment count specified in renderPass".
  //
  // Input attachments must be listed here *and* in the DescriptorSetLayout --
  // duplicated under both so the driver can choose how to make use of the info.
  std::vector<PipelineAttachment> attach;

  VkSubpassDescription2KHR subpassDesc;
  VkPipelineCreateFlags flags{0};

  // specialize(T) calls T::getMap() to get the VkSpecializationMapEntry and
  // VkSpecializationInfo structures for a particular VkShaderStage.
  template <typename T>
  WARN_UNUSED_RESULT int specialize(T& spec) {
    std::vector<VkSpecializationMapEntry> map;
    VkSpecializationInfo info;
    VkShaderStageFlags flags;
    if (spec.getMap(map, info, flags)) {
      logE("PipelineCreateInfo::specialize: getMap failed\n");
      return 1;
    }
    if (flags == 0) {
      logE("PipelineCreateInfo::specialize: no stages\n");
      return 1;
    }
    bool found = false;
    for (auto& s : stages) {
      if (!s.info.stage) {
        logE("PipelineCreateInfo::specialize: invalid stage = 0 in stages\n");
        return 1;
      }
      if (s.info.stage == flags) {
        found = true;
        s.specialize(map, info);
      }
    }
    if (!found) {
      logE("PipelineCreateInfo::specialize: no stages matched %x\n", flags);
      logE("PipelineCreateInfo::specialize must match a previous shader\n");
      return 1;
    }
    return 0;
  }
} PipelineCreateInfo;

// Pipeline represents a VkPipeline and VkPipelineLayout pair. This is useful
// for graphics and compute pipelines (they both have this in common).
//
// NOTE: Compute pipelines ignore the graphics pipeline members:
// * clearColors
// * members in PipelineCreateInfo info.
typedef struct Pipeline {
  // Pipeline constructor that calls PipelineCreateInfo constructor with pass_,
  // but does not retain it. This sets up a graphics pipeline.
  // NOTE: A Pipeline can be used for more than one RenderPass, as long as the
  // RenderPass objects are compatible.
  Pipeline(RenderPass& pass_);

  // Pipeline constructor that sets up a compute pipeline.
  Pipeline(CommandPool& computeCommandPool,
           std::shared_ptr<command::Shader> computeShader,
           std::string entryPointName = "main");

  Pipeline(Pipeline&&) = default;
  Pipeline(const Pipeline& other) = delete;
  virtual ~Pipeline();

  PipelineCreateInfo info;

  // pipelineLayout is the raw VkPipelineLayout.
  VkDebugPtr<VkPipelineLayout> pipelineLayout;
  // vk is the raw VkPipeline.
  VkDebugPtr<VkPipeline> vk;

  // setName forwards the setName call to vk.
  WARN_UNUSED_RESULT int setName(const std::string& name) {
    return vk.setName(name);
  }
  // getName forwards the getName call to vk.
  const std::string& getName() const { return vk.getName(); }

  // addDepthImage adds a depth/stencil image to dev.framebufs. Any Pipeline can
  // choose to addDepthImage or ignore the depth image, but there is only one
  // depth image, stored in dev.framebufs. Alas, that means formatChoices must
  // be the same for every call to addDepthImage().
  //
  // Advanced use cases like dynamic shadowmaps need to customize even more, to
  // use multiple depth images.
  int addDepthImage(const std::vector<VkFormat>& formatChoices,
                    VkClearValue depthClear = VkClearValue{1.0f, 0});

  // commandBufferType is for vkCmdBeginRenderPass when pipeline is executed.
  // Be aware of the rules around secondary command buffers:
  // * Set commandBufferType = VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS
  //   or do not use secondary command buffers at all during the render pass.
  //   (It must be specified in vkCmdBeginRenderPass or vkCmdNextSubpass.)
  // * No mixing of some drawing done in the primary and some in the secondary.
  //   "Commands cannot be called in a subpass using secondary command buffers"
  // * No vkCmdBeginRenderPass or vkCmdNextSubpass in the secondary: the
  //   primary command buffer must handle all render pass begin/end/next logic.
  //   VkCommandBufferInheritanceInfo also must be given as part of
  //   vkBeginCommandBuffer for all secondary buffers, and you must fill in the
  //   pass handle and subpass index - meaning the secondary buffer must all be
  //   in one subpass.
  VkSubpassContents commandBufferType{VK_SUBPASS_CONTENTS_INLINE};

  // clearColors is stored in each pipeline because
  // CommandBuffer::beginSubpass() can then conveniently put together the
  // VkRenderPassBeginInfo automatically. clearColors does not need to be
  // finalized until this pipeline is executed.
  //
  // The VkRenderPassBeginInfo is only used if an attachment's vk.loadOp is
  // VK_ATTACHMENT_LOAD_OP_CLEAR (which is the default for color attachments).
  //
  // clearColors defaults to a single VkClearValue to make normal uses simple:
  //   Pipeline pipe;
  //   float r(0), g(0), b(0), a(1);
  //   // Can assume clearColors.size() >= 1, so clearColors.at(0) is present:
  //   pipe.clearColors.at(0).color = {{r, g, b, a}};
  //
  // See addDepthImage which adds a VkClearValue for depth/stencil buffers.
  std::vector<VkClearValue> clearColors;

  // ctorError() sets up shaders (and references to them in info.stages), and
  // creates a VkPipeline. This Pipeline's index in RenderPass& pass is given
  // as a parameter. RenderPass::ctorError() calls this method for you on all
  // subpasses defined in it. But if your app uses pipelines that are not in
  // RenderPass (for changing state or whatever), you will need to call this on
  // the non-default pipelines.
  WARN_UNUSED_RESULT int ctorError(RenderPass& pass, size_t subpass_i);

  // ctorError() for a compute shader. Checks that the Pipeline was constructed
  // using the compute shader form of the constructor.
  WARN_UNUSED_RESULT int ctorError(CommandPool& computeCommandPool);

 protected:
  // Workaround bug in NVidia driver that driver does not keep a copy of the
  // VkPipelineShaderStageCreateInfo pName contents, just the pointer.
  std::vector<std::string> stageName;
} Pipeline;

// RenderPass generates pixels for the screen or somewhere else. It
// executes one or more pipelines.
//
// To create a RenderPass:
// 1. Instantiate the RenderPass: RenderPass renderpass(dev);
// 2. Add each Pipeline:          Pipeline &p = renderpass.addPipeline(dev);
//    and customize the Pipeline to suit your application.
//    Also take a look at:        science::PipeBuilder p{renderpass};
// 3. Instantiate Shader objects and load SPV binary code into them
// 4. Build and finalize the renderPass.
//        if (renderPass.ctorError(dev) { ... handle errors ... }
//
// Resources for understanding RenderPasses:
// https://gpuopen.com/vulkan-renderpasses/
typedef struct RenderPass {
  RenderPass(language::Device& dev) : vk{dev, vkDestroyRenderPass} {}
  RenderPass(RenderPass&&) = default;
  RenderPass(const RenderPass&) = delete;
  virtual ~RenderPass() = default;

  std::set<std::shared_ptr<Shader>> shaders;
  std::vector<std::shared_ptr<Pipeline>> pipelines;

  // addPipeline is a convenience method for adding a pipeline. It returns the
  // shared_ptr.
  WARN_UNUSED_RESULT std::shared_ptr<Pipeline> addPipeline() {
    pipelines.emplace_back(std::make_shared<Pipeline>(*this));
    return pipelines.back();
  }

  // Override this function to customize the subpass dependencies.
  // The default just executes subpasses serially (in order).
  WARN_UNUSED_RESULT virtual int getSubpassDeps(
      size_t subpass_i, VkSubpassDependency2KHR& dep) const;

  // ctorError() initializes each pipeline with their PipelineCreateInfo info.
  WARN_UNUSED_RESULT int ctorError();

  // setName forwards the setName call to vk.
  WARN_UNUSED_RESULT int setName(const std::string& name) {
    return vk.setName(name);
  }
  // getName forwards the getName call to vk.
  const std::string& getName() const { return vk.getName(); }

  // vk is the raw VkRenderPass.
  VkDebugPtr<VkRenderPass> vk;

  // getVkRenderPassCreateInfo2KHR is called by ctorError, but if your
  // app needs access to rpci2, call this to construct it.
  //
  // This function does not check if VK_KHR_create_renderpass2 is loaded.
  WARN_UNUSED_RESULT int getVkRenderPassCreateInfo2KHR(
      VkRenderPassCreateInfo2KHR& rpci2,
      std::vector<VkAttachmentDescription2KHR>& attachments,
      std::vector<VkAttachmentReference2KHR>& refs,
      std::vector<VkSubpassDescription2KHR>& subpasses,
      std::vector<VkSubpassDependency2KHR>& subpassdeps) const;

  // getVkRenderPassCreateInfo() sets up VkRenderPassCreateInfo rpci like
  // getVkRenderPassCreateInfo2KHR() but copies the results to rpci:
  //
  // * flags are copied as-is. Any unsupported flags may cause validation
  //   warnings.
  // * VkAttachmentDescriptions receive VkAttachmentDescription2KHR, but no
  //   pNext chains.
  // * VkAttachmentReferences receive VkAttachmentReference2KHR, but no
  //   pNext chains. aspectMask is ignored.
  // * VkSubpassDescriptions receive VkSubpassDescription2KHR, but no pNext
  //   chains. If viewMask is non-zero, refuse to convert and return an error.
  // * VkSubpassDependencys receive VkSubpassDependency2KHR, but no pNext
  //   chains. If viewOffset is non-zero, refuse to convert and return error.
  //
  // NOTE: viewMask and viewOffset relate to VkRenderPassMultiviewCreateInfo.
  WARN_UNUSED_RESULT int getVkRenderPassCreateInfo(
      VkRenderPassCreateInfo& rpci,
      std::vector<VkAttachmentDescription>& attachments,
      std::vector<VkAttachmentReference>& refs,
      std::vector<VkSubpassDescription>& subpasses,
      std::vector<VkSubpassDependency>& subpassdeps) const;

  // markDirty will mark this RenderPass as invalid, needing to be destroyed.
  // CommandPool::reallocCmdBufs() calls markDirty(). Possibly others.
  void markDirty() { dirty = true; }

  bool isDirty() const { return dirty; }

  // setTargetImage gives this RenderPass a different target, instead of the
  // dev.framebuffer which is the default. The memory::Image must be wrapped in
  // std::shared_ptr<> because this RenderPass holds a reference to it.
  WARN_UNUSED_RESULT int setTargetImage(std::shared_ptr<memory::Image> t) {
    image = t;
    imageFramebuf = std::make_shared<language::Framebuf>(vk.dev);
    return 0;
  }

  WARN_UNUSED_RESULT int setTargetDefault() {
    image.reset();
    imageFramebuf.reset();
    return 0;
  }

  bool isTargetDefault() const { return !image; }
  VkExtent3D getTargetExtent() const;
  VkFormat getTargetFormat() const;
  language::Framebuf& getTargetFramebuf() {
    if (imageFramebuf) {
      return *imageFramebuf;
    }
    return vk.dev.framebufs.at(0);
  }

 protected:
  bool dirty{false};
  std::shared_ptr<memory::Image> image;
  std::shared_ptr<language::Framebuf> imageFramebuf;
  friend class CommandPool;
} RenderPass;

}  // namespace command

// Some classes are split out of command.h just to break things up a little:
#include "fence.h"
// Some classes are split out of command.h just to break things up a little:
#include "command_buffer.h"
