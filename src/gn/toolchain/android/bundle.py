#!/usr/bin/env python3
# Copyright (c) 2017-2018 the Volcano Authors. Licensed under GPLv3.
#
# This builds the Android APK from its inputs:
# * AndroidManifest.xml, generated by this file, but configurable by
#   dropped add-to-android-manifest.txt files in certain dirs.
# * One .so file for each android platform the APK supports
# * Any resource files from the 'raw' dir
#
# Then the Android SDK provides a tool to sign the APK.

import argparse
import errno
import os
from select import select
import shutil
import subprocess
import sys

class runcmd(object):
  def __init__(self, env):
    self.have_out = False
    self.have_err = False
    self.env = env
    self.p = None

  def handle_output(self, is_stdout, out, data):
    out.write(data.decode("utf8", "ignore")
        .encode(sys.stdout.encoding, "replace").decode(sys.stdout.encoding))
    out.flush()

  def run(self, args):
    path_saved = os.environ["PATH"]
    if "PATH" in self.env:
      os.environ["PATH"] = self.env["PATH"]
    try:
      import pty
      masters, slaves = zip(pty.openpty(), pty.openpty())
      self.p = subprocess.Popen(args, stdout=slaves[0], stderr=slaves[1],
                                env = self.env)
      for fd in slaves: os.close(fd)
      readable = { masters[0]: sys.stdout, masters[1]: sys.stderr }
      while readable:
        for fd in select(readable, [], [])[0]:
          try: data = os.read(fd, 1024)
          except OSError as e:
            if e.errno != errno.EIO: raise
            del readable[fd]
            continue
          if not data:
            del readable[fd]
            continue
          self.handle_output(fd == masters[0], readable[fd], data)
          if fd != masters[0]:
            self.have_err = True
          else:
            self.have_out = True
      self.p.wait()
    except ImportError:
      if sys.platform != "win32":
        raise
      self.p = subprocess.Popen(args, shell=True)
      (o, e) = self.p.communicate()
      self.have_out = False
      self.have_err = False
      if o:
        self.have_out = True
        self.handle_output(True, sys.stdout, o)
      if e:
        self.have_err = True
        self.handle_output(False, sys.stdout, e)
    os.environ["PATH"] = path_saved


class runcmd_ignore_output(runcmd):
  def run(self, args):
    super(runcmd_ignore_output, self).run(args)
    if self.p.returncode != 0:
      print("run(%s) returned %d" % (args, self.p.returncode))
      sys.exit(1)


class runcmd_return_stdout(runcmd):
  def __init__(self, env, max_out_len):
    super(runcmd_return_stdout, self).__init__(env)
    self.max_out_len = max_out_len
    self.result = b""
    self.also_stderr = False

  def and_stderr(self):
    self.also_stderr = True
    return self

  def handle_output(self, is_stdout, out, data):
    if is_stdout or self.also_stderr:
      self.result += data
      if len(self.result) > self.max_out_len:
        self.p.kill()

  def run(self, args):
    super(runcmd_return_stdout, self).run(args)
    if len(self.result) > self.max_out_len:
      print("run(%s) got more than %d bytes" % (args, self.max_out_len))
      sys.exit(1)
    if self.p.returncode != 0:
      print("run(%s) returned %d" % (args, self.p.returncode))
      sys.exit(1)
    return (self.result
                .decode("utf8", "ignore")
                .encode(sys.stdout.encoding, "replace")
                .decode(sys.stdout.encoding))


def split_dirs(path):
  # os.path.normpath cleans up the string $path
  dirs = os.path.normpath(path).split(os.sep)
  if dirs[-1] == "":
    # path ended with a trailing os.sep. Remove that.
    dirs = dirs[:-1]
  if dirs[0] == "" or ":" in dirs[0]:
    # path is an absolute path, starting with os.sep
    dirs = dirs[1:]
    dirs[0] = "%s%s" % (os.sep, dirs[0])
  return dirs


def map_vargendir(gen, toolosdir):
  dirs = split_dirs(gen)
  pre = []
  post = []
  # somewhere in $gen is "/gen/". Insert toolosdir just before that.
  found_gen = False
  for d in dirs:
    if d == "gen":
      if found_gen:
        print("%s: --gen must contain 'gen' exactly once:" % sys.argv[0])
        print("    %s" % gen)
        sys.exit(1)
      found_gen = True
    if found_gen:
      post.append(d)
    else:
      pre.append(d)
  if not found_gen:
    print("%s: --gen must contain 'gen' exactly once:" % sys.argv[0])
    print("    %s" % gen)
    sys.exit(1)
  return [os.sep.join(pre + [d] + post) for d in toolosdir]


class AppSettings:
  def __init__(self):
    self.manifestadd = ""
    self.havemanifestadd = False
    self.scanresults = ""
    self.manifestpath = ""
    self.unaligned = ""
    self.key_pass = "android"
    self.libs = []

  # delete_if_archs_changed() checks native/lib for each target arch. If
  # there is a dir there that should not be, delete it.
  # If any dir was deleted, delete $out as well to force a rebuild.
  #
  # This does *not* protect the APK from having stale self.xml_resources
  # or self.raw_assets files. Leftover assets are a bug, but a stale leftover
  # binary which sort-of works and sort-of does not is excruciating.
  #
  # Knowing which assets are stale would be a complex and fragile feature
  # anyway. If it bites you, the fix is to delete all self.xml_resources and
  # self.raw_assets dirs, then rebuild.
  def delete_if_archs_changed(self, out):
    want_archs = []
    for lib in self.libs:
      dirs = split_dirs(lib)
      if len(dirs) < 2:
        print("invalid file.so: %s" % lib)
        sys.exit(1)
      want_archs.append(dirs[-2])

    lib_path = os.path.join(self.gen, "native", "lib")
    if not os.path.isdir(lib_path):
      print("%s not found: cannot link" % lib_path)
      sys.exit(1)

    for arch in want_archs:
      arch_path = os.path.join(lib_path, arch)
      if not os.path.isdir(arch_path):
        print("%s not found in %s: cannot link" % (arch_path, os.getcwd()))
        sys.exit(1)
      libname = "lib%s.so" % self.target
      p = os.path.join(arch_path, libname)
      if not os.path.isfile(p):
        print("%s not found: cannot link" % p)
        sys.exit(1)

    should_rebuild = False
    for got_arch in os.listdir(lib_path):
      if got_arch not in want_archs:
        unwanted = os.path.join(lib_path, got_arch)
        print("delete stale %s" % unwanted)
        should_rebuild = True
        shutil.rmtree(unwanted, ignore_errors=True)
    if should_rebuild:
      os.unlink(out)

  # scanDir looks for known files in d that will be merged with AppSettings
  # NOTE: Each d must have *identical* values. Per-architecture manifest is
  # not supported; instead, you would create a different APK for each that
  # only supported that one architecture. (The Play Store supports that.)
  def scanDir(self, d):
    add = ""
    try:
      with open(os.path.join(d, "add-to-android-manifest.txt"), "r") as addfile:
        for line in addfile:
          add += line
    except OSError as e:
      if e.errno != errno.ENOENT: raise
    self.scanresults += add

    assets_add = os.path.join(d, "assets")
    # map assets_add back from got.toolosdir to gen
    for t in self.toolosdir:
      prefix = os.path.join(t, "")
      if assets_add.startswith(prefix + "gen"):
        self.raw_assets.append(assets_add[len(prefix):])
        break

  def addLib(self, lib):
    if not self.havemanifestadd:
      self.havemanifestadd = True
      self.manifestadd = self.scanresults
    elif self.manifestadd != self.scanresults:
      print(lib)
      print("add-to-android-manifest.txt cannot change across archs")
      print("first was:")
      print(self.manifestadd)
      print("second was:")
      print(self.scanresults)
      sys.exit(1)
    self.scanresults = ""
    self.libs.append(lib)

  def writeManifest(self):
    manifestdir = os.path.join(self.gen, "app", "src", "main")
    try: os.makedirs(manifestdir)
    except OSError as e:
      if e.errno != errno.EEXIST: raise
    self.manifestpath = os.path.join(manifestdir, "AndroidManifest.xml")
    manifcontents = """<?xml version="1.0"?>
  <!--
  There are bugs building with Android Studio.
  Currently, the native library gets dropped by Android Studio unless the
  following command is run *after* opening the project, but *before*
  doing a "Build APK" in Android Studio:

  cd ../out
  for arch in arm64-v8a armeabi-v7a x86 x86_64; do (
    cd .externalNativeBuild/cmake/debug/\$arch && \
    $ANDROID_HOME/cmake/3*/bin/ninja -v
  ); done
  -->
  <manifest xmlns:android="http://schemas.android.com/apk/res/android"
      package="{mainClass}"
      android:versionCode="1"
      android:versionName="0.1">
      {manifestadd}
      <uses-permission android:name="android.permission.SET_DEBUG_APP"/>
      <uses-feature android:name="android.software.leanback"
                    android:required="false" />
      <uses-feature android:name="android.hardware.touchscreen"
                    android:required="false" />
      <uses-feature android:name="android.hardware.gamepad"
                    android:required="false"/>
      <uses-sdk android:minSdkVersion="{minsdk}"
                android:targetSdkVersion="{latestsdk}"/>
      <application
        android:hasCode="false"
        android:label="VolcanoSample"
        android:theme="@android:style/Theme.Translucent.NoTitleBar"
        android:debuggable="true">
          <activity android:name="android.app.NativeActivity"
              android:label="{target}"
              android:screenOrientation="fullUser"
              android:configChanges="{configChanges}"
              android:exported="true">

              <!-- pass name of .so to NativeActivity -->
              <meta-data android:name="android.app.lib_name"
                         android:value="{target}"/>
              <intent-filter>
                  <action android:name="android.intent.action.MAIN"/>
                  <category android:name="android.intent.category.LAUNCHER"/>
                  <category android:name="android.intent.category.LEANBACK_LAUNCHER"/>
              </intent-filter>
          </activity>
      </application>
  </manifest>""".format(
      mainClass=self.mainClass,
      manifestadd=self.manifestadd,
      minsdk=self.minsdk,
      latestsdk=self.latestsdk,
      target=self.target,
      configChanges="|".join([
        "keyboardHidden",
        "keyboard",
        "orientation",
        "screenSize",
        "screenLayout",
        "smallestScreenSize",
        "locale",
        "layoutDirection",
        "uiMode",
      ]))
    with open(self.manifestpath, "a+") as manif:
      manif.seek(0)
      oldcontent = manif.read()
      if oldcontent != manifcontents:
        manif.seek(0)
        manif.truncate()
        manif.write(manifcontents)
      else:
        print("# up to date: %s" % self.manifestpath)

  def runOldAapt(self):
    if not self.manifestpath:
      print("must call writeManifest first")
      sys.exit(1)

    astudio_lib = os.path.join(self.gen, "native")
    layers = os.path.join(self.sdk, "ndk-bundle", "sources", "third_party",
                          "vulkan", "src", "build-android", "jniLibs")
    if "V_ANDROID_SKIP_VALIDATION_LAYERS" in os.environ:
      # delete validation layers out of astudio_lib
      for arch in os.listdir(layers):
        archdir = os.path.join(layers, arch)
        dest = os.path.join(astudio_lib, "lib", arch)
        if os.path.isdir(archdir) and os.path.isdir(dest):
          for layer in os.listdir(archdir):
            out = os.path.join(dest, layer)
            if os.path.isfile(out):
              os.unlink(out)
    else:
      # copy validation layers to astudio_lib
      for arch in os.listdir(layers):
        archdir = os.path.join(layers, arch)
        dest = os.path.join(astudio_lib, "lib", arch)
        if os.path.isdir(archdir) and os.path.isdir(dest):
          for layer in os.listdir(archdir):
            out = os.path.join(dest, layer)
            shutil.copy2(os.path.join(archdir, layer), out)
            # "touch" the output (windows mtime bug in shutil.copy2).
            os.utime(out, None)

    cmd = [
      os.path.join(self.buildtoolsdir, "aapt"),
      "package", "-v", "-f",
      "-M", self.manifestpath,
      "-I", "%s/platforms/android-%s/android.jar" % (
          self.sdk, self.latestsdk)
    ]
    for assetdir in self.raw_assets:
      if os.path.isdir(assetdir):
        cmd += [ "-A", assetdir ]

    runcmd_ignore_output(os.environ.copy()).run(cmd + [
        "-F", self.unaligned, astudio_lib
      ])
    runcmd_ignore_output(os.environ.copy()).run([
        "jarsigner", "-verbose", "-keystore", self.keystore,
        "-storepass", self.key_pass, "-keypass", self.key_pass,
        self.unaligned, "androiddebugkey",
      ])
    self.runZipalign()

  def runAapt(self, is_debug):
    objpath = os.path.join(self.gen, "obj")
    try: os.makedirs(objpath)
    except OSError as e:
      if e.errno != errno.EEXIST: raise

    def runOneAapt(args, srcs, obj):
      try:
        obj_time = os.stat(obj).st_mtime
        obj_is_newer = True
        for src in srcs:
          src_time = os.stat(src).st_mtime
          if src_time > obj_time:
            obj_is_newer = False
        # any raised exception before now will just cause a rebuild
        if obj_is_newer:
          print("# up to date: %s" % obj)
          return
      except OSError as e:
        if e.errno != errno.ENOENT: raise
      runcmd_ignore_output(os.environ.copy()).run([
        os.path.join(self.buildtoolsdir, "aapt2")] + args)

    def runAaptCompile(args, srcs, obj):
      cmd = ["compile", "-v"]
      if is_debug:
        cmd.append("--no-crunch")
      runOneAapt(cmd + args, srcs, obj)

    compiled = []
    if os.path.isdir(self.xml_resources):
      for f in os.listdir(self.xml_resources):
        obj = os.path.join(objpath, "%s.flat" % f)
        src = os.path.join(self.xml_resources, f)
        compiled.append(obj)
        runAaptCompile(["-o", objpath, src], [src], obj)

    assets = []
    asset_inputs = []
    for assetdir in self.raw_assets:
      if os.path.isdir(assetdir):
        assets = [ "-A", assetdir ]
        for f in os.listdir(assetdir):
          asset_inputs.append(os.path.join(assetdir, f))

    self.delete_if_archs_changed(self.unaligned)
    runOneAapt(["link",
        "-v",
        "-o", self.unaligned,
        "-I", "%s/platforms/android-%s/android.jar" % (
            self.sdk, self.latestsdk),
        "--manifest", self.manifestpath,
      ] + assets + compiled,
      asset_inputs + compiled + [self.manifestpath],
      self.unaligned)

    saved_cwd = os.getcwd()
    os.chdir(os.path.join(self.gen, "native"))
    ziprun = runcmd(os.environ.copy())
    ziprun.run([
        "zip",
        "-u", # add or update files if their mtime is newer
        "-D", # do not add directories
        "-r", # recurse into the "lib" dir and subdirs
        os.path.join("..", "%s-unaligned.apk" % self.target),
        "lib",
      ])
    os.chdir(saved_cwd)
    if ziprun.p.returncode not in (0, 12):
      print("run(%s) returned %d" % ("zip", self.p.returncode))
      sys.exit(1)

    self.runZipalign()
    sys.stdout.write("apksigner   : ")
    sys.stdout.flush()
    runcmd_ignore_output(os.environ.copy()).run([
        os.path.join(self.buildtoolsdir, "apksigner"), "sign",
        "--verbose",
        "--ks", self.keystore,
        "--ks-key-alias", "androiddebugkey",
        "--ks-pass", "pass:%s" % self.key_pass,
        "--key-pass", "pass:%s" % self.key_pass,
        self.out,
      ])

  def runZipalign(self):
    print("zipalign -f 4 %s" % self.unaligned)
    runcmd_ignore_output(os.environ.copy()).run([
        os.path.join(self.buildtoolsdir, "zipalign"), "-f", "4",
        self.unaligned, self.out,
      ])

def bundle(got):
  if len(got.libs) < 1:
    print("Usage: %s file.so ... file.so" % sys.argv[0])
    sys.exit(1)

  # sanity check got.libs against got.toolosdir
  vargendir = map_vargendir(got.gen, got.toolosdir)
  # raw_assets is just under got.gen, compare to add-to-...txt dirs
  raw_assets = os.path.join(got.gen, "assets")
  must_add = os.path.isdir(raw_assets)
  # add-to-...txt files are under the vargendir dirs
  if not must_add:
    for d in vargendir:
      if os.path.isfile(os.path.join(d, "add-to-android-manifest.txt")):
        must_add = True
        break

  settings = AppSettings()
  settings.out = got.out
  settings.target = got.target
  settings.gen = got.gen
  settings.toolosdir = got.toolosdir
  settings.unaligned = os.path.join(got.gen, "%s-unaligned.apk" % got.target)
  settings.mainClass = "com.ndsol.VolcanoSample%s" % got.target
  settings.sdk = got.sdk
  settings.buildtoolsdir = os.path.join(got.sdk, "build-tools", got.buildtools)
  settings.keystore = got.keystore
  settings.minsdk = got.minsdk
  settings.latestsdk = got.latestsdk
  settings.raw_assets = [ raw_assets ]
  settings.xml_resources = os.path.join(got.gen, "res")

  for lib in got.libs:
    if not os.path.isfile(lib):
      print("%s: %s not found" % (sys.argv[0], lib))
      sys.exit(1)
    # parse .add.txt file if it exists
    adddir = {}
    try:
      with open("%s.add.txt" % lib, "r") as addfile:
        for line in addfile:
          adddir[line.strip()] = 1
    except OSError as e:
      if e.errno != errno.ENOENT: raise

    # If must_add then verify that .add.txt matches vargendir.
    # This sanity-checks that .add.txt was written for the most basic case,
    # where the main target wrote raw_asset or add-to-...txt files.
    if must_add:
      valid = False
      for d in vargendir:
        if d in adddir:
          valid = True
          break
      if not valid:
        print("%s: invalid file:" % sys.argv[0])
        print("    %s.add.txt" % lib)
        print("    It must contain one of: (may also have other dirs)")
        for d in vargendir:
          print("      %s" % d)
        sys.exit(1)

    # Scan the dirs in adddir for add-to-...txt files, even those not in
    # the main target.
    for d in adddir:
      settings.scanDir(d)

    settings.addLib(lib)

  settings.writeManifest()

  if got.use_old_aapt:
    settings.runOldAapt()
    return

  # Check got.buildtools version
  ver = got.buildtools.split(".")
  if int(ver[0]) < 28 or (int(ver[0]) == 28 and
                          int(ver[1]) == 0 and int(ver[2]) < 1):
    print("buildtools %s does not include aapt2 and apksigner." %
          got.buildtools)
    print("You must --use_old_aapt by putting this in args.gn:")
    print("  android_use_old_aapt = true")
    sys.exit(1)
  settings.runAapt(got.debug)

if __name__ == "__main__":
  parser = argparse.ArgumentParser(description="Write .apk from .so files.")
  parser.add_argument("--target", required=True)
  parser.add_argument("--out", required=True)
  parser.add_argument("--gen", required=True)
  parser.add_argument("--sdk", required=True)
  parser.add_argument("--buildtools", required=True)
  parser.add_argument("--keystore", required=True)
  parser.add_argument("--use_old_aapt", action="store_true")
  parser.add_argument("--debug", action="store_true")
  parser.add_argument("--minsdk", required=True)
  parser.add_argument("--latestsdk", required=True)
  parser.add_argument("--toolosdir", action="append", required=True)
  parser.add_argument("libs", nargs=argparse.REMAINDER)
  bundle(parser.parse_args())
